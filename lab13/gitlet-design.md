# Gitlet Design Document

**Name**: Jilin He

## Classes and Data Structures

### Command
Cope with different commands received from commander.

* Current_path - represents the current working path.

### Commit 
Store information of per commit.

* Message - contains the message of commit.
* Timestamp - time at which a commit was created. Assigned by the constructor.
* Parent - the parent commit of a commit object.
* Blobs - An arraylist of blobs.

### Blob
Store information of each file.
* Filebasic - contains file name and file path.
* Filecontent - contains file's content.
* File_ID - the hashcode of this file.

## Algorithms

### Command Class

`init()` - Create a new Gitlet version-control system in the current directory. Essentially, it will send
a commit with no files and a message `intial commit`, which contains three fundamental elements: id, timestamp, and message.

`add()` - Adds a copy of the file as it currently exists to the staging area. If the current working version of the file is identical to the version in the
current commit, do not stage it to be added, and remove it from the staging area if it is already there.

`commitOp()` - Saves a snapshot of certain files in the current commit and staging area so they can be restored at a later time, creating a new commit.

`remove()` - Unstage the file if it is currently staged for addition.

`log()` - Starting at the current head commit, display information about each commit backwards along the commit tree until the initial commit, following the first parent commit links, ignoring any second parents found in merge commits. 

`globalLog()` - Like log, except displays information about all commits ever made. The order of the commits does not matter.

`find()` - Prints out the ids of all commits that have the given commit message, one per line. 

`status()` - Displays what branches currently exist, and marks the current branch with a *. Also displays what files have been staged for addition or removal.

`checkout()` - 

`branch()` - Creates a new branch with the given name, and points it at the current head node.

 `rm-branch()` - Deletes the branch with the given name. This only means to delete the pointer associated with the branch; it does not mean to delete all commits that were created under the branch, or anything like that.
 
 `reset()` - Checks out all the files tracked by the given commit.
 
 `merge()` - Merges files from the given branch into the current branch. 
 
### Commit Class
`Commit()` - The class constructor. Store the information of each commit, which contains the corresponding message, id and timestamp.

`commitAdd()` - This method focus on adding blobs from the staging area into the current commit. The input is the blob structure.

### Blob Class
`Blob()` - The class constructor. Store the information of each added file, which includes file name, file's path and hashcode generated by sha1.

`blobAdd()` - Add the state of file into blob data structure.

## Persistence
In order to persist the settings of our `gitlet` program, we need to save the state of the version each time we do a specific command. Then, we should do

1. Write the file into disk after a command executed. For example, we have initialized a repository at the current working directory, and then we implement a series of modifications, may including any valid operations. Because after each command is being called and successfully being executed, we would like to exit this program and resume at any time we want. 
    * `init` : create a new repository
    * `add` : add the file into stage directory to restore this modification
    * `rm` : same with `add`
    * `commit` : store the files in stage directory into commit directory
2. Write the commands into disk. Especially, like the commands `merge`, `commit`, `log` and so forth, they are the landmark of your repository, storing the state information instead of the contents of the files. After executing each command, we store this command with a unique hashcode, which makes sure the convenience of later locating. 

When we resume to our working, we can look for the previous files that we stored, to retrieve our state and get start directly. Since we serialize our input object during the writing process, we can do deserialize these object and read them off. 
